{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PeaPods","text":"<p>A Python library for simulating Ising spin systems with modern Monte Carlo methods. The core simulation loop is written in Rust (via PyO3) for performance, with a thin Python wrapper for ease of use.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Ising ferromagnets and spin glasses on periodic Bravais lattices (hypercubic, triangular, or any custom neighbor offsets)</li> <li>Arbitrary, bimodal (\u00b1J), or Gaussian coupling distributions</li> <li>Multiple replicas with overlap statistics for spin glass order parameters</li> <li>Metropolis, Gibbs, Swendsen-Wang, Wolff, parallel tempering, Houdayer ICM, J\u00f6rg, and CMR algorithms</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<pre><code>import numpy as np\nfrom peapods import Ising\n\n# 2D ferromagnet with cluster updates and parallel tempering\nmodel = Ising((32, 32), temperatures=np.linspace(1.5, 3.0, 32), n_replicas=2)\nmodel.sample(n_sweeps=5000, sweep_mode=\"metropolis\",\n             cluster_update_interval=1, pt_interval=1)\nprint(model.binder_cumulant)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>uv pip install peapods\n</code></pre> <p>Pre-built wheels are available for Linux (x86_64, aarch64), macOS (Intel, Apple Silicon), and Windows (x86_64).</p>"},{"location":"api/","title":"API Reference","text":"<p>Ising model on a periodic Bravais lattice with Monte Carlo sampling.</p> <p>Supports ferromagnets and spin glasses on hypercubic, triangular, FCC, BCC, or any custom lattice defined by neighbor offsets. Multiple replicas enable overlap-based spin glass order parameters.</p> <p>Attributes:</p> Name Type Description <code>lattice_shape</code> <p>Shape of the lattice as a tuple of ints.</p> <code>n_dims</code> <p>Number of spatial dimensions.</p> <code>n_neighbors</code> <p>Number of nearest neighbors per site.</p> <code>temperatures</code> <p>Array of temperatures for parallel tempering.</p> <code>n_temps</code> <p>Number of temperature points.</p> <code>n_replicas</code> <p>Number of replicas per temperature.</p> <code>n_disorder</code> <p>Number of disorder realizations.</p> <code>couplings</code> <p>Coupling array with shape <code>(*lattice_shape, n_neighbors)</code>.</p> <code>binder_cumulant</code> <p>Binder cumulant <code>1 - &lt;m^4&gt; / (3 &lt;m^2&gt;^2)</code>, set after <code>sample</code>.</p> <code>heat_capacity</code> <p>Heat capacity <code>(&lt;E^2&gt; - &lt;E&gt;^2) / T^2</code>, set after <code>sample</code>.</p> <code>sg_binder</code> <p>Spin glass Binder parameter <code>1 - &lt;q^4&gt; / (3 &lt;q^2&gt;^2)</code>, set after <code>sample</code> with <code>n_replicas &gt;= 2</code>.</p>"},{"location":"api/#peapods.Ising.__init__","title":"<code>__init__(lattice_shape, couplings='ferro', temperatures=np.geomspace(0.1, 10, 32), n_replicas=1, n_disorder=1, neighbor_offsets=None, geometry=None)</code>","text":"<p>Create an Ising model.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_shape</code> <p>Shape of the periodic lattice, e.g. <code>(32, 32)</code> for a 2D 32x32 grid.</p> required <code>couplings</code> <p>Coupling configuration. One of <code>\"ferro\"</code> (all +1), <code>\"bimodal\"</code> (random +/-1), <code>\"gaussian\"</code> (standard normal), or a NumPy array of shape <code>(*lattice_shape, n_neighbors)</code>.</p> <code>'ferro'</code> <code>temperatures</code> <p>Array of temperatures for the simulation. Defaults to 32 points log-spaced from 0.1 to 10.</p> <code>geomspace(0.1, 10, 32)</code> <code>n_replicas</code> <p>Number of independent replicas per temperature. Must be</p> <p>= 2 for overlap statistics and Houdayer moves.</p> <code>1</code> <code>n_disorder</code> <p>Number of disorder realizations. Each realization gets its own coupling array.</p> <code>1</code> <code>neighbor_offsets</code> <p>List of integer offset vectors defining nearest neighbors, e.g. <code>[[1, 0], [0, 1]]</code> for a square lattice. Mutually exclusive with <code>geometry</code>.</p> <code>None</code> <code>geometry</code> <p>Named lattice geometry. One of <code>\"triangular\"</code> / <code>\"tri\"</code>, <code>\"fcc\"</code>, or <code>\"bcc\"</code>. Mutually exclusive with <code>neighbor_offsets</code>. If neither is given, defaults to a hypercubic lattice.</p> <code>None</code>"},{"location":"api/#peapods.Ising.reset","title":"<code>reset()</code>","text":"<p>Reset all spins to a random configuration.</p>"},{"location":"api/#peapods.Ising.sample","title":"<code>sample(n_sweeps, sweep_mode='metropolis', cluster_update_interval=None, cluster_mode='sw', pt_interval=None, overlap_cluster_update_interval=None, overlap_cluster_build_mode='houdayer', overlap_cluster_mode='wolff', warmup_ratio=0.25, collect_csd=False, collect_top_clusters=False, autocorrelation_max_lag=None, sequential=False, equilibration_diagnostic=False)</code>","text":"<p>Run Monte Carlo sampling and compute observables.</p> <p>After sampling, the following attributes are set on the instance:</p> <ul> <li><code>binder_cumulant</code> \u2014 Binder cumulant per temperature.</li> <li><code>heat_capacity</code> \u2014 Heat capacity per temperature.</li> <li><code>sg_binder</code> \u2014 Spin glass Binder parameter (only with <code>n_replicas &gt;= 2</code>).</li> <li><code>fk_csd</code> \u2014 FK cluster size distribution (only with <code>collect_csd=True</code>).</li> <li><code>top_cluster_sizes</code> \u2014 Average relative sizes of the 4 largest overlap   clusters per temperature, shape <code>(n_temps, 4)</code> (only with   <code>collect_top_clusters=True</code>).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>n_sweeps</code> <p>Total number of Monte Carlo sweeps (including warmup).</p> required <code>sweep_mode</code> <p>Single-spin update algorithm. <code>\"metropolis\"</code> or <code>\"gibbs\"</code>.</p> <code>'metropolis'</code> <code>cluster_update_interval</code> <p>If set, perform a cluster update every this many sweeps.</p> <code>None</code> <code>cluster_mode</code> <p>Cluster algorithm. <code>\"sw\"</code> (Swendsen-Wang) or <code>\"wolff\"</code>.</p> <code>'sw'</code> <code>pt_interval</code> <p>If set, attempt parallel tempering swaps every this many sweeps.</p> <code>None</code> <code>overlap_cluster_update_interval</code> <p>If set, attempt overlap cluster moves every this many sweeps. Requires <code>n_replicas &gt;= 2</code>.</p> <code>None</code> <code>overlap_cluster_build_mode</code> <p>Overlap cluster algorithm. <code>\"houdayer\"</code>, <code>\"jorg\"</code>, or <code>\"cmrN\"</code> where N &gt;= 2 is the group size (e.g. <code>\"cmr\"</code>, <code>\"cmr2\"</code>, <code>\"cmr3\"</code>). CMR-N with N &gt;= 3 requires <code>n_replicas &gt;= N</code>. Note: N &gt;= 3 is experimental and likely does not satisfy detailed balance; under active revision.</p> <code>'houdayer'</code> <code>overlap_cluster_mode</code> <p>Cluster type used inside the overlap move. <code>\"wolff\"</code> or <code>\"sw\"</code>.</p> <code>'wolff'</code> <code>warmup_ratio</code> <p>Fraction of sweeps discarded as warmup before collecting statistics. Default 0.25.</p> <code>0.25</code> <code>collect_csd</code> <p>If <code>True</code>, collect the Fortuin-Kasteleyn cluster size distribution.</p> <code>False</code> <code>collect_top_clusters</code> <p>If <code>True</code>, collect average relative sizes of the 4 largest overlap clusters per temperature.</p> <code>False</code> <code>sequential</code> <p>If <code>True</code>, disable inner-loop parallelism over replicas/temperatures. Use when outer-level parallelism over disorder realizations already saturates all physical cores.</p> <code>False</code> <p>Returns:</p> Type Description <p>Raw results dictionary with keys like <code>\"mags\"</code>, <code>\"energies\"</code>, etc.</p>"},{"location":"api/#peapods.Ising.equilibration_delta","title":"<code>equilibration_delta(j_squared=1.0)</code>","text":"<p>Compute equilibration diagnostic \u0394(t) = e(t) - J\u00b2\u03b2 z (1 - q_l(t)).</p> <p>\u0394 approaches zero as the system thermalizes (Zhu et al. 2015). Note: the Rust energy convention is e = +\u03a3 J s_i s_j / N (no minus sign), so the sign here is flipped relative to the Hamiltonian form.</p> <p>Parameters:</p> Name Type Description Default <code>j_squared</code> <p>Average squared coupling \u27e8J\u00b2\u27e9. 1.0 for bimodal and Gaussian (unit variance) spin glasses.</p> <code>1.0</code> <p>Returns:</p> Type Description <p>Tuple of (sweeps, delta) where sweeps has shape <code>(n_checkpoints,)</code></p> <p>and delta has shape <code>(n_checkpoints, n_temps)</code>.</p>"},{"location":"api/#peapods.Ising.get_energies","title":"<code>get_energies()</code>","text":"<p>Return the mean energies per temperature from the last sample run.</p>"}]}